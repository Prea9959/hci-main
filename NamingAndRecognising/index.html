<!doctype html>
<html lang="en">
 <head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Emotion Learning Game</title>
  <script src="/_sdk/element_sdk.js"></script>
   <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.22.0/dist/tf.min.js"></script>
   <script src="https://cdn.jsdelivr.net/npm/@teachablemachine/image@0.8.5/dist/teachablemachine-image.min.js"></script>
  <style>
        body {
            box-sizing: border-box;
            margin: 0;
            padding: 20px;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100%;
            color: #2d3748;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.98);
            border-radius: 25px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .title {
            font-size: 2.8rem;
            font-weight: bold;
            background: linear-gradient(45deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 10px;
        }

        .subtitle {
            font-size: 1.3rem;
            color: #764ba2;
            margin-bottom: 20px;
            font-weight: 600;
        }

        .game-menu {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .menu-button {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            border-radius: 15px;
            padding: 25px;
            font-size: 1.2rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 8px 20px rgba(102, 126, 234, 0.4);
        }

        .menu-button:hover {
            transform: translateY(-5px);
            box-shadow: 0 12px 30px rgba(102, 126, 234, 0.6);
        }

        .menu-button.secondary {
            background: linear-gradient(135deg, #f093fb, #f5576c);
        }

        .menu-button.tertiary {
            background: linear-gradient(135deg, #4facfe, #00f2fe);
        }

        .menu-button.quaternary {
            background: linear-gradient(135deg, #43e97b, #38f9d7);
        }

        .game-screen {
            display: none;
        }

        .game-screen.active {
            display: block;
        }

        .back-button {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            border-radius: 12px;
            padding: 12px 25px;
            margin-bottom: 20px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .back-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        /* Flashcard Styles */
        .flashcard-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 25px;
        }

        .flashcard {
            width: 350px;
            height: 450px;
            background: white;
            border-radius: 20px;
            box-shadow: 0 15px 35px rgba(102, 126, 234, 0.3);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: transform 0.6s;
            transform-style: preserve-3d;
            position: relative;
        }

        .flashcard:hover {
            transform: translateY(-5px);
        }

        .flashcard.flipped {
            transform: rotateY(180deg);
        }

        .flashcard-front, .flashcard-back {
            position: absolute;
            width: 100%;
            height: 100%;
            backface-visibility: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 25px;
            border-radius: 20px;
        }

        .flashcard-back {
            transform: rotateY(180deg);
            background: linear-gradient(135deg, #ffeaa7, #fab1a0);
        }

        .human-face {
            width: 200px;
            height: 200px;
            border-radius: 50%;
            margin-bottom: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
        }

        .emotion-name {
            font-size: 2.2rem;
            font-weight: bold;
            color: #667eea;
            text-align: center;
            margin-bottom: 10px;
        }
        .flashcard-question {
            font-size: 1.5rem;
            color: #2d3748;
            text-align: center;
            margin-bottom: 20px;
            font-weight: bold;
        }

        .flashcard-controls {
            display: flex;
            gap: 20px;
            margin-top: 25px;
        }

        .control-button {
            background: linear-gradient(135deg, #4facfe, #00f2fe);
            color: white;
            border: none;
            border-radius: 12px;
            padding: 15px 30px;
            cursor: pointer;
            font-size: 1.1rem;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .control-button:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(79, 172, 254, 0.4);
        }

        .control-button.prev {
            background: linear-gradient(135deg, #f093fb, #f5576c);
        }

        /* Matching Game Styles */
        .matching-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }

        .emoji-section, .names-section {
            background: rgba(102, 126, 234, 0.1);
            border-radius: 15px;
            padding: 25px;
        }

        .section-title {
            text-align: center;
            font-size: 1.5rem;
            font-weight: bold;
            color: #667eea;
            margin-bottom: 20px;
        }

        .emoji-grid, .names-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
            gap: 15px;
        }

        .draggable-emoji {
            background: white;
            border: 3px solid #667eea;
            border-radius: 12px;
            padding: 15px;
            text-align: center;
            cursor: grab;
            transition: all 0.3s ease;
            -webkit-user-select: none;
            -ms-user-select: none;
            -moz-user-select: none;
            user-select: none;
        }

        .draggable-emoji:hover {
            transform: scale(1.1);
            box-shadow: 0 8px 20px rgba(102, 126, 234, 0.4);
        }

        .draggable-emoji.dragging {
            opacity: 0.5;
            transform: rotate(5deg);
            cursor: grabbing;
        }

        .draggable-face {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            object-fit: cover;
        }

        .drop-zone {
            background: white;
            border: 3px dashed #667eea;
            border-radius: 12px;
            padding: 20px;
            text-align: center;
            transition: all 0.3s ease;
            font-size: 1.2rem;
            font-weight: bold;
            color: #667eea;
            min-height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .drop-zone.drag-over {
            border-color: #4facfe;
            background: rgba(79, 172, 254, 0.1);
            transform: scale(1.05);
        }

        .drop-zone.matched {
            border-color: #43e97b;
            background: rgba(67, 233, 123, 0.2);
            color: #43e97b;
        }

        .drop-zone.wrong {
            border-color: #f5576c;
            background: rgba(245, 87, 108, 0.2);
            animation: shake 0.5s ease-in-out;
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-10px); }
            75% { transform: translateX(10px); }
        }

        .score-display {
            text-align: center;
            font-size: 1.6rem;
            font-weight: bold;
            color: #667eea;
            margin-bottom: 25px;
            padding: 20px;
            background: rgba(102, 126, 234, 0.1);
            border-radius: 12px;
        }

        /* Quiz Styles */
        .quiz-question {
            text-align: center;
            margin-bottom: 35px;
        }

        .quiz-face {
            width: 250px;
            height: 250px;
            border-radius: 50%;
            margin: 0 auto 25px;
            box-shadow: 0 15px 40px rgba(0, 0, 0, 0.2);
            object-fit: cover;
        }

        .quiz-prompt {
            font-size: 1.6rem;
            color: #667eea;
            margin-bottom: 35px;
            font-weight: bold;
        }

        .quiz-options {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 20px;
            margin-bottom: 25px;
        }

        .quiz-option {
            background: white;
            border: 3px solid #667eea;
            border-radius: 12px;
            padding: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1.2rem;
            text-align: center;
            font-weight: bold;
            color: #667eea;
        }

        .quiz-option:hover {
            border-color: #4facfe;
            background: rgba(79, 172, 254, 0.1);
            transform: translateY(-3px);
        }

        .quiz-option.correct {
            border-color: #43e97b;
            background: rgba(67, 233, 123, 0.2);
            color: #43e97b;
            animation: pulse 0.5s ease-in-out;
        }

        .quiz-option.incorrect {
            border-color: #f5576c;
            background: rgba(245, 87, 108, 0.2);
            color: #f5576c;
            animation: shake 0.5s ease-in-out;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
            to { opacity: 1; transform: translate(-50%, -50%) scale(1); }
        }

        @keyframes fadeOut {
            from { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            to { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
        }

        .quiz-feedback {
            text-align: center;
            font-size: 1.3rem;
            font-weight: bold;
            margin: 25px 0;
            min-height: 40px;
            padding: 15px;
            border-radius: 12px;
        }

        .quiz-feedback.correct {
            color: #43e97b;
            background: rgba(67, 233, 123, 0.2);
        }

        .quiz-feedback.incorrect {
            color: #f5576c;
            background: rgba(245, 87, 108, 0.2);
        }

        .next-question-button {
            background: linear-gradient(135deg, #4facfe, #00f2fe);
            color: white;
            border: none;
            border-radius: 12px;
            padding: 15px 30px;
            cursor: pointer;
            font-size: 1.1rem;
            display: block;
            margin: 0 auto;
            transition: all 0.3s ease;
            font-weight: bold;
        }

        .next-question-button:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(79, 172, 254, 0.4);
        }

        .next-question-button:disabled {
            background: #a0aec0;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        /* Soundboard Styles */
        .soundboard-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 25px;
            margin-bottom: 30px;
        }

        .sound-card {
            background: white;
            border: 3px solid #667eea;
            border-radius: 20px;
            padding: 25px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
        }

        .sound-card:hover {
            transform: translateY(-8px);
            border-color: #4facfe;
            box-shadow: 0 15px 30px rgba(79, 172, 254, 0.4);
        }

        .sound-card.playing {
            border-color: #43e97b;
            background: rgba(67, 233, 123, 0.1);
            animation: pulse 1s ease-in-out infinite;
        }

        .sound-face {
            width: 150px;
            height: 150px;
            border-radius: 50%;
            margin: 0 auto 20px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
            object-fit: cover;
        }

        .sound-name {
            font-size: 1.6rem;
            font-weight: bold;
            color: #667eea;
            margin-bottom: 15px;
        }

        .sound-description {
            font-size: 1rem;
            color: #718096;
            margin-bottom: 20px;
            line-height: 1.4;
        }

        .play-button {
            background: linear-gradient(135deg, #43e97b, #38f9d7);
            color: white;
            border: none;
            border-radius: 25px;
            padding: 12px 25px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .play-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(67, 233, 123, 0.4);
        }

        .play-button.playing {
            background: linear-gradient(135deg, #f093fb, #f5576c);
        }

        .completion-message {
            text-align: center;
            padding: 30px;
            background: rgba(67, 233, 123, 0.2);
            border: 3px solid #43e97b;
            border-radius: 20px;
            margin: 25px 0;
            font-size: 1.5rem;
            font-weight: bold;
            color: #43e97b;
            animation: pulse 2s ease-in-out infinite;
        }

        /* Language Selector Styles */
        .language-selector {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
            display: flex;
            gap: 10px;
            background: white;
            padding: 10px;
            border-radius: 15px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.2);
        }

        .language-button {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: 2px solid transparent;
            border-radius: 10px;
            padding: 10px 15px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .language-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .language-button.active {
            background: linear-gradient(135deg, #43e97b, #38f9d7);
            border-color: #43e97b;
        }

        /* Voice Button Styles */
        .voice-button {
            background: linear-gradient(135deg, #f093fb, #f5576c);
            color: white;
            border: none;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            cursor: pointer;
            font-size: 1.2rem;
            transition: all 0.3s ease;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            margin-left: 10px;
            vertical-align: middle;
        }

        .voice-button:hover {
            transform: scale(1.1);
            box-shadow: 0 5px 15px rgba(240, 147, 251, 0.4);
        }

        .voice-button.playing {
            animation: pulse 1s ease-in-out infinite;
        }

        /* Navigation Help Styles */
        .navigation-help {
            background: rgba(102, 126, 234, 0.1);
            border: 2px solid #667eea;
            border-radius: 15px;
            padding: 15px;
            margin-bottom: 20px;
            text-align: center;
            font-size: 1rem;
            color: #667eea;
        }

        .navigation-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 20px;
            flex-wrap: wrap;
        }

        .menu-return-button {
            background: linear-gradient(135deg, #f093fb, #f5576c);
            color: white;
            border: none;
            border-radius: 12px;
            padding: 12px 25px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .menu-return-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(240, 147, 251, 0.4);
        }

        .menu-return-button.module-menu {
            background: linear-gradient(135deg, #43e97b, #38f9d7);
        }

        @media (max-width: 600px) {
            .container {
                padding: 20px;
            }
            
            .title {
                font-size: 2.2rem;
            }
            
            .flashcard {
                width: 300px;
                height: 400px;
            }
            
            .human-face {
                width: 150px;
                height: 150px;
            }

            .quiz-face {
                width: 200px;
                height: 200px;
            }

            .game-menu {
                grid-template-columns: 1fr;
            }

            .matching-container {
                grid-template-columns: 1fr;
            }

            .soundboard-grid {
                grid-template-columns: 1fr;
            }

            /* Mobile language selector */
            .language-selector {
                top: 10px;
                right: 10px;
                padding: 8px;
                gap: 8px;
                flex-direction: row;
                flex-wrap: wrap;
            }

            .language-button {
                padding: 8px 12px;
                font-size: 0.8rem;
            }

            /* Mobile navigation buttons */
            .navigation-buttons {
                flex-direction: column;
                gap: 10px;
            }

            .menu-return-button {
                width: 100%;
            }
        }

        /* Facial Recognition Styles */
        .facial-recognition-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 25px;
        }

        .webcam-wrapper {
            position: relative;
            border-radius: 20px;
            overflow: hidden;
            box-shadow: 0 15px 40px rgba(0, 0, 0, 0.2);
        }

        #webcam-container canvas {
            border-radius: 20px;
            max-width: 100%;
        }

        .prediction-container {
            width: 100%;
            max-width: 400px;
            background: rgba(102, 126, 234, 0.1);
            border-radius: 15px;
            padding: 20px;
        }

        .prediction-title {
            text-align: center;
            font-size: 1.4rem;
            font-weight: bold;
            color: #667eea;
            margin-bottom: 15px;
        }

        .prediction-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px;
            margin-bottom: 8px;
            background: white;
            border-radius: 10px;
            border: 2px solid #667eea;
        }

        .prediction-item.top-prediction {
            border-color: #43e97b;
            background: rgba(67, 233, 123, 0.15);
        }

        .prediction-emotion {
            font-weight: bold;
            color: #2d3748;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .prediction-bar-container {
            flex: 1;
            margin: 0 15px;
            height: 20px;
            background: #e2e8f0;
            border-radius: 10px;
            overflow: hidden;
        }

        .prediction-bar {
            height: 100%;
            background: linear-gradient(135deg, #667eea, #764ba2);
            border-radius: 10px;
            transition: width 0.3s ease;
        }

        .prediction-bar.top-prediction {
            background: linear-gradient(135deg, #43e97b, #38f9d7);
        }

        .prediction-percentage {
            font-weight: bold;
            color: #667eea;
            min-width: 50px;
            text-align: right;
        }

        .webcam-controls {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .webcam-btn {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            border-radius: 12px;
            padding: 15px 30px;
            cursor: pointer;
            font-size: 1.1rem;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .webcam-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(102, 126, 234, 0.4);
        }

        .webcam-btn:disabled {
            background: #a0aec0;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .webcam-btn.stop {
            background: linear-gradient(135deg, #f093fb, #f5576c);
        }

        .webcam-status {
            text-align: center;
            padding: 15px;
            background: rgba(102, 126, 234, 0.1);
            border-radius: 10px;
            color: #667eea;
            font-weight: bold;
        }

        .webcam-status.error {
            background: rgba(245, 87, 108, 0.1);
            color: #f5576c;
        }

        .webcam-status.success {
            background: rgba(67, 233, 123, 0.1);
            color: #43e97b;
        }

        .detected-emotion-display {
            text-align: center;
            padding: 25px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            border-radius: 20px;
            color: white;
            margin-bottom: 20px;
        }

        .detected-emotion-label {
            font-size: 1.2rem;
            margin-bottom: 10px;
            opacity: 0.9;
        }

        .detected-emotion-name {
            font-size: 2.5rem;
            font-weight: bold;
        }

        .model-note {
            text-align: center;
            font-size: 0.9rem;
            color: #718096;
            margin-top: 15px;
            padding: 15px;
            background: rgba(113, 128, 150, 0.1);
            border-radius: 10px;
        }

        .model-note a {
            color: #667eea;
            text-decoration: underline;
        }

        @media (max-width: 600px) {
            .prediction-container {
                padding: 15px;
            }
            
            .prediction-item {
                flex-direction: column;
                align-items: flex-start;
                gap: 8px;
            }
            
            .prediction-bar-container {
                width: 100%;
                margin: 0;
            }
            
            .prediction-percentage {
                width: 100%;
                text-align: left;
            }
        }
    </style>
  <style>@view-transition { navigation: auto; }</style>
  <script src="/_sdk/data_sdk.js" type="text/javascript"></script>
  <script src="https://cdn.tailwindcss.com" type="text/javascript"></script>
 </head>
 <body>
  <!-- Language Selector -->
  <div class="language-selector">
   <button class="language-button active" onclick="changeLanguage('en')" data-lang="en">English</button>
   <button class="language-button" onclick="changeLanguage('ms')" data-lang="ms">Bahasa Melayu</button>
   <button class="language-button" onclick="changeLanguage('zh')" data-lang="zh">‰∏≠Êñá</button>
  </div>

  <div class="container">
   <div id="main-menu" class="game-screen active">
    <div class="header">
     <h1 class="title" id="game-title">Emotion Learning Game<button class="voice-button" onclick="speakText('game-title')" title="Listen">üîä</button></h1>
     <p class="subtitle" id="welcome-message">Learn to recognize and name emotions!<button class="voice-button" onclick="speakText('welcome-message')" title="Listen">üîä</button></p>
    </div>
    <div class="game-menu"><button class="menu-button" onclick="showFlashcards()" id="flashcard-btn"> üé¥ Flashcards </button> <button class="menu-button secondary" onclick="showMatchingGame()" id="matching-btn"> üéØ Matching Game </button> <button class="menu-button tertiary" onclick="showQuiz()" id="quiz-btn"> üß† Expression Quiz </button> <button class="menu-button quaternary" onclick="showSoundboard()" id="soundboard-btn"> üé§ Voice Soundboard </button> <button class="menu-button" style="background: linear-gradient(135deg, #f093fb, #764ba2);" onclick="showFacialRecognition()" id="facial-btn"> üì∑ Facial Recognition </button>
    </div>
   </div><!-- Flashcards Screen -->
   <div id="flashcards-screen" class="game-screen">
    <div class="navigation-help" id="nav-help-flashcards">
     Click cards to flip and learn emotions! Use navigation buttons below to return to menus.
     <button class="voice-button" onclick="speakText('nav-help-flashcards')" title="Listen">üîä</button>
    </div>
    <button class="back-button" onclick="showMainMenu()">‚Üê <span data-translate="back-to-submenu">Back to Sub-module Menu</span></button>
    <div class="flashcard-container">
     <div class="flashcard" id="flashcard" onclick="flipCard()">
      <div class="flashcard-front">
       <svg class="human-face" id="card-face" viewbox="0 0 200 200" xmlns="http://www.w3.org/2000/svg"><!-- Face will be drawn here -->
       </svg>
      </div>
      <div class="flashcard-back">
       <div class="emotion-name" id="card-emotion-name">
       </div>
      </div>
     </div>
     <div class="flashcard-controls"><button class="control-button prev" onclick="previousCard()" data-translate="previous">‚Üê Previous</button> <button class="control-button" onclick="nextCard()" data-translate="next">Next ‚Üí</button>
     </div>
     <div class="navigation-buttons">
      <button class="menu-return-button" onclick="showMainMenu()"><span data-translate="return-submenu">Return to Sub-module Menu</span></button>
     </div>
    </div>
   </div><!-- Drag & Drop Matching Game Screen -->
   <div id="matching-screen" class="game-screen">
    <div class="navigation-help" id="nav-help-matching">
     Drag facial expressions to match emotion names! Match all 6 to complete.
     <button class="voice-button" onclick="speakText('nav-help-matching')" title="Listen">üîä</button>
    </div>
    <button class="back-button" onclick="showMainMenu()">‚Üê <span data-translate="back-to-submenu">Back to Sub-module Menu</span></button>
    <div class="score-display">
     Score: <span id="matching-score">0</span> | Matches: <span id="matches-count">0</span>/6
    </div>
    <div class="matching-container">
     <div class="emoji-section">
      <div class="section-title">
       üë§ Facial Expressions
      </div>
      <div class="emoji-grid" id="emoji-grid"><!-- Draggable faces will be generated here -->
      </div>
     </div>
     <div class="names-section">
      <div class="section-title">
       üìù Emotion Names
      </div>
      <div class="names-grid" id="names-grid"><!-- Drop zones will be generated here -->
      </div>
     </div>
    </div>
    <div style="text-align: center; margin-top: 25px;"><button class="control-button" id="new-game-btn" onclick="resetMatchingGame()">üîÑ New Game</button>
    </div>
    <div class="navigation-buttons">
     <button class="menu-return-button" onclick="showMainMenu()"><span data-translate="return-submenu">Return to Sub-module Menu</span></button>
    </div>
   </div><!-- Quiz Screen -->
   <div id="quiz-screen" class="game-screen">
    <div class="navigation-help" id="nav-help-quiz">
     Look at the face and choose the correct emotion! Answer all 10 questions.
     <button class="voice-button" onclick="speakText('nav-help-quiz')" title="Listen">üîä</button>
    </div>
    <button class="back-button" onclick="showMainMenu()">‚Üê <span data-translate="back-to-submenu">Back to Sub-module Menu</span></button>
    <div class="score-display">
     Question <span id="question-number">1</span> of 10 | Score: <span id="quiz-score">0</span>
    </div>
    <div class="quiz-question">
     <svg class="quiz-face" id="quiz-face" viewbox="0 0 200 200" xmlns="http://www.w3.org/2000/svg"><!-- Face will be drawn here -->
     </svg>
     <div class="quiz-prompt">
      Happy
     </div>
    </div>
    <div class="quiz-options" id="quiz-options"><!-- Options will be generated by JavaScript -->
    </div>
    <div class="quiz-feedback" id="quiz-feedback"></div><button class="next-question-button" id="next-question" onclick="nextQuestion()" disabled> Next Question </button>
    <div class="navigation-buttons">
     <button class="menu-return-button" onclick="showMainMenu()"><span data-translate="return-submenu">Return to Sub-module Menu</span></button>
    </div>
   </div><!-- Soundboard Screen -->
   <div id="soundboard-screen" class="game-screen">
    <div class="navigation-help" id="nav-help-soundboard">
     Click on each emotion card to hear how it sounds! Explore all emotions.
     <button class="voice-button" onclick="speakText('nav-help-soundboard')" title="Listen">üîä</button>
    </div>
    <button class="back-button" onclick="showMainMenu()">‚Üê <span data-translate="back-to-submenu">Back to Sub-module Menu</span></button>
    <div class="soundboard-controls">
     <h2 style="text-align: center; color: #667eea; margin-bottom: 20px;">üé§ Human Voice Soundboard</h2>
     <p style="text-align: center; color: #718096; margin-bottom: 20px;">Click on each emotion to hear how it sounds with human voice!</p>
    </div>
    <div class="soundboard-grid" id="soundboard-grid"><!-- Sound cards will be generated by JavaScript -->
    </div>
    <div class="navigation-buttons">
     <button class="menu-return-button" onclick="showMainMenu()"><span data-translate="return-submenu">Return to Sub-module Menu</span></button>
    </div>
   </div><!-- Facial Recognition Screen -->
   <div id="facial-screen" class="game-screen">
    <div class="navigation-help" id="nav-help-facial">
     Use your webcam to detect emotions! Make different facial expressions and see the prediction.
     <button class="voice-button" onclick="speakText('nav-help-facial')" title="Listen">üîä</button>
    </div>
    <button class="back-button" onclick="stopFacialRecognition(); showMainMenu()">‚Üê <span data-translate="back-to-submenu">Back to Sub-module Menu</span></button>
    <div class="facial-recognition-container">
     <div class="webcam-status" id="webcam-status">Click "Start Camera" to begin emotion detection</div>
     <div class="webcam-controls">
      <button class="webcam-btn" id="start-webcam-btn" onclick="initFacialRecognition()">üì∑ Start Camera</button>
      <button class="webcam-btn stop" id="stop-webcam-btn" onclick="stopFacialRecognition()" style="display: none;">‚èπ Stop Camera</button>
     </div>
     <div class="webcam-wrapper">
      <div id="webcam-container"></div>
     </div>
     <div class="detected-emotion-display" id="detected-emotion-display" style="display: none;">
      <div class="detected-emotion-label" id="detected-label">Detected Emotion:</div>
      <div class="detected-emotion-name" id="detected-emotion">-</div>
     </div>
     <div class="prediction-container" id="prediction-container" style="display: none;">
      <div class="prediction-title" id="prediction-title">Emotion Predictions</div>
      <div id="label-container"></div>
     </div>
     <div class="model-note" id="model-note">
      <strong>Note:</strong> This feature uses a Teachable Machine model to detect emotions. 
      For best results, ensure good lighting and face the camera directly.
      <br><br>
      <a href="https://teachablemachine.withgoogle.com/train/image" target="_blank">Create your own emotion model with Teachable Machine ‚Üí</a>
     </div>
    </div>
    <div class="navigation-buttons">
     <button class="menu-return-button" onclick="stopFacialRecognition(); showMainMenu()"><span data-translate="return-submenu">Return to Sub-module Menu</span></button>
    </div>
   </div>
  </div>
  <script>
        // Current language
        let currentLanguage = 'en';

        // Translation data for UI elements
        const translations = {
            en: {
                'game-title': 'Emotion Learning Game',
                'welcome-message': 'Learn to recognize and name emotions!',
                'flashcard-btn': 'üé¥ Flashcards',
                'matching-btn': 'üéØ Matching Game',
                'quiz-btn': 'üß† Expression Quiz',
                'soundboard-btn': 'üé§ Voice Soundboard',
                'facial-btn': 'üì∑ Facial Recognition',
                'back-to-submenu': 'Back to Sub-module Menu',
                'return-submenu': 'Return to Sub-module Menu',
                'return-module': 'Return to Module Menu',
                'nav-help-flashcards': 'Click cards to flip and learn emotions! Use navigation buttons below to return to menus.',
                'nav-help-matching': 'Drag facial expressions to match emotion names! Match all 6 to complete.',
                'nav-help-quiz': 'Look at the face and choose the correct emotion! Answer all 10 questions.',
                'nav-help-soundboard': 'Click on each emotion card to hear how it sounds! Explore all emotions.',
                'nav-help-facial': 'Use your webcam to detect emotions! Make different facial expressions and see the prediction.',
                'previous': '‚Üê Previous',
                'next': 'Next ‚Üí',
                'Happy': 'Happy',
                'Sad': 'Sad',
                'Angry': 'Angry',
                'Surprised': 'Surprised',
                'Scared': 'Scared',
                'Excited': 'Excited',
                'happy-description': 'A feeling of joy and contentment. You might feel happy when something good happens!',
                'sad-description': 'A feeling of sorrow or unhappiness. People feel sad when something disappointing happens.',
                'angry-description': 'A strong feeling of displeasure. You might feel angry when something unfair happens.',
                'surprised-description': 'A feeling when something unexpected happens. Surprise can be good or bad!',
                'scared-description': 'A feeling of fear or worry. People feel scared when they sense danger.',
                'excited-description': 'A feeling of enthusiasm and energy. You feel excited when looking forward to something!',
                'happy-sound': 'Laughing and cheerful voice',
                'sad-sound': 'Soft crying and sighing',
                'angry-sound': 'Frustrated and upset voice',
                'surprised-sound': 'Gasping with amazement',
                'scared-sound': 'Nervous and frightened voice',
                'excited-sound': 'Energetic and enthusiastic voice',
                'new-game': 'üîÑ New Game',
                'next-question': 'Next Question',
                'start-camera': 'üì∑ Start Camera',
                'stop-camera': '‚èπ Stop Camera',
                'webcam-status-ready': 'Click "Start Camera" to begin emotion detection',
                'webcam-status-loading': 'Loading model and starting webcam...',
                'webcam-status-running': 'Webcam is running - detecting emotions!',
                'webcam-status-error': 'Error: Could not access webcam. Please allow camera access.',
                'detected-emotion-label': 'Detected Emotion:',
                'prediction-title': 'Emotion Predictions',
                'note-label': 'Note:',
                'model-note': 'This feature uses a Teachable Machine model to detect emotions. For best results, ensure good lighting and face the camera directly.',
                'model-link': 'Create your own emotion model with Teachable Machine ‚Üí'
            },
            ms: {
                'game-title': 'Permainan Pembelajaran Emosi',
                'welcome-message': 'Belajar mengenal dan menamakan emosi!',
                'flashcard-btn': 'üé¥ Kad Imbasan',
                'matching-btn': 'üéØ Permainan Padanan',
                'quiz-btn': 'üß† Kuiz Ekspresi',
                'soundboard-btn': 'üé§ Papan Suara',
                'facial-btn': 'üì∑ Pengecaman Wajah',
                'back-to-submenu': 'Kembali ke Menu Sub-modul',
                'return-submenu': 'Kembali ke Menu Sub-modul',
                'return-module': 'Kembali ke Menu Modul',
                'nav-help-flashcards': 'Klik kad untuk membalik dan belajar emosi! Gunakan butang navigasi di bawah untuk kembali ke menu.',
                'nav-help-matching': 'Seret ekspresi muka untuk dipadankan dengan nama emosi! Padankan semua 6 untuk selesai.',
                'nav-help-quiz': 'Lihat wajah dan pilih emosi yang betul! Jawab semua 10 soalan.',
                'nav-help-soundboard': 'Klik pada setiap kad emosi untuk mendengar bunyinya! Terokai semua emosi.',
                'nav-help-facial': 'Gunakan kamera web anda untuk mengesan emosi! Buat ekspresi muka yang berbeza dan lihat ramalan.',
                'previous': '‚Üê Sebelumnya',
                'next': 'Seterusnya ‚Üí',
                'Happy': 'Gembira',
                'Sad': 'Sedih',
                'Angry': 'Marah',
                'Surprised': 'Terkejut',
                'Scared': 'Takut',
                'Excited': 'Teruja',
                'happy-description': 'Perasaan gembira dan puas hati. Anda mungkin merasa gembira apabila sesuatu yang baik berlaku!',
                'sad-description': 'Perasaan dukacita atau tidak gembira. Orang merasa sedih apabila sesuatu yang mengecewakan berlaku.',
                'angry-description': 'Perasaan tidak puas hati yang kuat. Anda mungkin merasa marah apabila sesuatu yang tidak adil berlaku.',
                'surprised-description': 'Perasaan apabila sesuatu yang tidak dijangka berlaku. Kejutan boleh jadi baik atau buruk!',
                'scared-description': 'Perasaan takut atau bimbang. Orang merasa takut apabila mereka merasakan bahaya.',
                'excited-description': 'Perasaan bersemangat dan bertenaga. Anda merasa teruja apabila menantikan sesuatu!',
                'happy-sound': 'Suara ketawa dan ceria',
                'sad-sound': 'Tangisan lembut dan mengeluh',
                'angry-sound': 'Suara kecewa dan marah',
                'surprised-sound': 'Terkejut dengan kagum',
                'scared-sound': 'Suara gugup dan takut',
                'excited-sound': 'Suara bertenaga dan bersemangat',
                'new-game': 'üîÑ Permainan Baru',
                'next-question': 'Soalan Seterusnya',
                'start-camera': 'üì∑ Mulakan Kamera',
                'stop-camera': '‚èπ Hentikan Kamera',
                'webcam-status-ready': 'Klik "Mulakan Kamera" untuk mula mengesan emosi',
                'webcam-status-loading': 'Memuatkan model dan memulakan kamera web...',
                'webcam-status-running': 'Kamera web sedang berjalan - mengesan emosi!',
                'webcam-status-error': 'Ralat: Tidak dapat mengakses kamera web. Sila benarkan akses kamera.',
                'detected-emotion-label': 'Emosi Dikesan:',
                'prediction-title': 'Ramalan Emosi',
                'note-label': 'Nota:',
                'model-note': 'Ciri ini menggunakan model Teachable Machine untuk mengesan emosi. Untuk hasil terbaik, pastikan pencahayaan yang baik dan hadap kamera secara langsung.',
                'model-link': 'Cipta model emosi anda sendiri dengan Teachable Machine ‚Üí'
            },
            zh: {
                'game-title': 'ÊÉÖÁª™Â≠¶‰π†Ê∏∏Êàè',
                'welcome-message': 'Â≠¶‰π†ËØÜÂà´ÂíåÂëΩÂêçÊÉÖÁª™ÔºÅ',
                'flashcard-btn': 'üé¥ ÊäΩËÆ§Âç°',
                'matching-btn': 'üéØ ÈÖçÂØπÊ∏∏Êàè',
                'quiz-btn': 'üß† Ë°®ÊÉÖÊµãÈ™å',
                'soundboard-btn': 'üé§ ËØ≠Èü≥Êùø',
                'facial-btn': 'üì∑ Èù¢ÈÉ®ËØÜÂà´',
                'back-to-submenu': 'ËøîÂõûÂ≠êÊ®°ÂùóËèúÂçï',
                'return-submenu': 'ËøîÂõûÂ≠êÊ®°ÂùóËèúÂçï',
                'return-module': 'ËøîÂõûÊ®°ÂùóËèúÂçï',
                'nav-help-flashcards': 'ÁÇπÂáªÂç°ÁâáÁøªËΩ¨Âπ∂Â≠¶‰π†ÊÉÖÁª™ÔºÅ‰ΩøÁî®‰∏ãÈù¢ÁöÑÂØºËà™ÊåâÈíÆËøîÂõûËèúÂçï„ÄÇ',
                'nav-help-matching': 'ÊãñÂä®Èù¢ÈÉ®Ë°®ÊÉÖ‰∏éÊÉÖÁª™ÂêçÁß∞ÂåπÈÖçÔºÅÂåπÈÖçÂÖ®ÈÉ®6‰∏™Âç≥ÂèØÂÆåÊàê„ÄÇ',
                'nav-help-quiz': 'ÁúãËÑ∏ÈÉ®Âπ∂ÈÄâÊã©Ê≠£Á°ÆÁöÑÊÉÖÁª™ÔºÅÂõûÁ≠îÂÖ®ÈÉ®10‰∏™ÈóÆÈ¢ò„ÄÇ',
                'nav-help-soundboard': 'ÁÇπÂáªÊØè‰∏™ÊÉÖÁª™Âç°‰ª•Âê¨Âê¨ÂÆÉÁöÑÂ£∞Èü≥ÔºÅÊé¢Á¥¢ÊâÄÊúâÊÉÖÁª™„ÄÇ',
                'nav-help-facial': '‰ΩøÁî®‰Ω†ÁöÑÊëÑÂÉèÂ§¥Ê£ÄÊµãÊÉÖÁª™ÔºÅÂÅöÂá∫‰∏çÂêåÁöÑÈù¢ÈÉ®Ë°®ÊÉÖÔºåÁúãÁúãÈ¢ÑÊµãÁªìÊûú„ÄÇ',
                'previous': '‚Üê ‰∏ä‰∏Ä‰∏™',
                'next': '‰∏ã‰∏Ä‰∏™ ‚Üí',
                'Happy': 'Âø´‰πê',
                'Sad': 'ÊÇ≤‰º§',
                'Angry': 'ÁîüÊ∞î',
                'Surprised': 'ÊÉäËÆ∂',
                'Scared': 'ÂÆ≥ÊÄï',
                'Excited': 'ÂÖ¥Â•ã',
                'happy-description': 'ÂñúÊÇ¶ÂíåÊª°Ë∂≥ÁöÑÊÑüËßâ„ÄÇÂΩìÂ•Ω‰∫ãÂèëÁîüÊó∂‰Ω†ÂèØËÉΩ‰ºöÊÑüÂà∞Âø´‰πêÔºÅ',
                'sad-description': 'ÊÇ≤‰º§Êàñ‰∏çÂø´‰πêÁöÑÊÑüËßâ„ÄÇÂΩì‰ª§‰∫∫Â§±ÊúõÁöÑ‰∫ãÊÉÖÂèëÁîüÊó∂Ôºå‰∫∫‰ª¨‰ºöÊÑüÂà∞ÊÇ≤‰º§„ÄÇ',
                'angry-description': 'Âº∫ÁÉàÁöÑ‰∏çÊÇ¶ÊÑü„ÄÇÂΩì‰∏çÂÖ¨Âπ≥ÁöÑ‰∫ãÊÉÖÂèëÁîüÊó∂Ôºå‰Ω†ÂèØËÉΩ‰ºöÊÑüÂà∞ÁîüÊ∞î„ÄÇ',
                'surprised-description': 'ÂΩìÊÑèÊÉ≥‰∏çÂà∞ÁöÑ‰∫ãÊÉÖÂèëÁîüÊó∂ÁöÑÊÑüËßâ„ÄÇÊÉäËÆ∂ÂèØËÉΩÊòØÂ•ΩÁöÑÊàñÂùèÁöÑÔºÅ',
                'scared-description': 'ÊÅêÊÉßÊàñÊãÖÂøÉÁöÑÊÑüËßâ„ÄÇÂΩì‰∫∫‰ª¨ÊÑüÂà∞Âç±Èô©Êó∂‰ºöÊÑüÂà∞ÂÆ≥ÊÄï„ÄÇ',
                'excited-description': 'ÁÉ≠ÊÉÖÂíåÊ¥ªÂäõÁöÑÊÑüËßâ„ÄÇÂΩì‰Ω†ÊúüÂæÖÊüê‰∫ãÊó∂‰ºöÊÑüÂà∞ÂÖ¥Â•ãÔºÅ',
                'happy-sound': 'Á¨ëÂ£∞ÂíåÊ¨¢Âø´ÁöÑÂ£∞Èü≥',
                'sad-sound': 'ËΩªÊüîÁöÑÂì≠Ê≥£ÂíåÂèπÊÅØ',
                'angry-sound': 'Ê≤Æ‰∏ßÂíå‰∏çÂÆâÁöÑÂ£∞Èü≥',
                'surprised-sound': 'ÊÉäËÆ∂ÁöÑÂñòÊÅØ',
                'scared-sound': 'Á¥ßÂº†ÂíåÂÆ≥ÊÄïÁöÑÂ£∞Èü≥',
                'excited-sound': 'ÂÖÖÊª°Ê¥ªÂäõÂíåÁÉ≠ÊÉÖÁöÑÂ£∞Èü≥',
                'new-game': 'üîÑ Êñ∞Ê∏∏Êàè',
                'next-question': '‰∏ã‰∏Ä‰∏™ÈóÆÈ¢ò',
                'start-camera': 'üì∑ ÂêØÂä®ÊëÑÂÉèÂ§¥',
                'stop-camera': '‚èπ ÂÅúÊ≠¢ÊëÑÂÉèÂ§¥',
                'webcam-status-ready': 'ÁÇπÂáª"ÂêØÂä®ÊëÑÂÉèÂ§¥"ÂºÄÂßãÊ£ÄÊµãÊÉÖÁª™',
                'webcam-status-loading': 'Ê≠£Âú®Âä†ËΩΩÊ®°ÂûãÂíåÂêØÂä®ÊëÑÂÉèÂ§¥...',
                'webcam-status-running': 'ÊëÑÂÉèÂ§¥Ê≠£Âú®ËøêË°å - Ê£ÄÊµãÊÉÖÁª™‰∏≠ÔºÅ',
                'webcam-status-error': 'ÈîôËØØÔºöÊó†Ê≥ïËÆøÈóÆÊëÑÂÉèÂ§¥„ÄÇËØ∑ÂÖÅËÆ∏ÊëÑÂÉèÂ§¥ËÆøÈóÆ„ÄÇ',
                'detected-emotion-label': 'Ê£ÄÊµãÂà∞ÁöÑÊÉÖÁª™Ôºö',
                'prediction-title': 'ÊÉÖÁª™È¢ÑÊµã',
                'note-label': 'Ê≥®ÊÑèÔºö',
                'model-note': 'Ê≠§ÂäüËÉΩ‰ΩøÁî®Teachable MachineÊ®°ÂûãÊù•Ê£ÄÊµãÊÉÖÁª™„ÄÇ‰∏∫Ëé∑ÂæóÊúÄ‰Ω≥ÊïàÊûúÔºåËØ∑Á°Æ‰øùËâØÂ•ΩÁöÑÁÖßÊòéÂπ∂Áõ¥Êé•Èù¢ÂØπÊëÑÂÉèÂ§¥„ÄÇ',
                'model-link': '‰ΩøÁî®Teachable MachineÂàõÂª∫‰Ω†Ëá™Â∑±ÁöÑÊÉÖÁª™Ê®°Âûã ‚Üí'
            }
        };
        
        // Shared Yes/No translations for quiz
        const yesNoTranslations = {
            en: { Yes: 'Yes', No: 'No' },
            ms: { Yes: 'Ya', No: 'Tidak' },
            zh: { Yes: 'ÊòØ', No: 'Âê¶' }
        };

        // Function to change language
        function changeLanguage(lang) {
            currentLanguage = lang;
            
            // Update active button
            document.querySelectorAll('.language-button').forEach(btn => {
                btn.classList.remove('active');
                if (btn.dataset.lang === lang) {
                    btn.classList.add('active');
                }
            });
            
            // Update all translatable elements
            updateTranslations();
        }

        // Function to update all translations
        function updateTranslations() {
            const lang = translations[currentLanguage];
            
            // Helper function to safely update text node
            const safeUpdateTextNode = (element, newText) => {
                if (!element) return;
                const textNode = Array.from(element.childNodes).find(node => node.nodeType === Node.TEXT_NODE);
                if (textNode) {
                    textNode.textContent = newText;
                } else {
                    // If no text node exists, create one as the first child
                    const newTextNode = document.createTextNode(newText);
                    element.insertBefore(newTextNode, element.firstChild);
                }
            };
            
            // Update main UI elements
            const gameTitle = document.getElementById('game-title');
            const welcomeMsg = document.getElementById('welcome-message');
            
            safeUpdateTextNode(gameTitle, lang['game-title']);
            safeUpdateTextNode(welcomeMsg, lang['welcome-message']);
            
            document.getElementById('flashcard-btn').textContent = lang['flashcard-btn'];
            document.getElementById('matching-btn').textContent = lang['matching-btn'];
            document.getElementById('quiz-btn').textContent = lang['quiz-btn'];
            document.getElementById('soundboard-btn').textContent = lang['soundboard-btn'];
            document.getElementById('facial-btn').textContent = lang['facial-btn'];
            
            // Update navigation help texts
            const updateNavHelp = (id, key) => {
                const elem = document.getElementById(id);
                if (elem) {
                    safeUpdateTextNode(elem, lang[key]);
                }
            };
            
            updateNavHelp('nav-help-flashcards', 'nav-help-flashcards');
            updateNavHelp('nav-help-matching', 'nav-help-matching');
            updateNavHelp('nav-help-quiz', 'nav-help-quiz');
            updateNavHelp('nav-help-soundboard', 'nav-help-soundboard');
            updateNavHelp('nav-help-facial', 'nav-help-facial');
            
            // Update New Game button in Matching Game
            const newGameBtn = document.getElementById('new-game-btn');
            if (newGameBtn) {
                newGameBtn.textContent = lang['new-game'];
            }
            
            // Update Next Question button in Quiz (only if not showing "Play Again")
            const nextQuestionBtn = document.getElementById('next-question');
            if (nextQuestionBtn && quizQuestions && currentQuestionIndex < quizQuestions.length) {
                nextQuestionBtn.textContent = lang['next-question'];
            }
            
            // Update all data-translate elements
            document.querySelectorAll('[data-translate]').forEach(elem => {
                const key = elem.getAttribute('data-translate');
                if (lang[key]) {
                    elem.textContent = lang[key];
                }
            });
            
            // Update emotion names and descriptions
            updateEmotionTranslations();
            
            // Update facial recognition UI
            updateFacialRecognitionUI();
        }

        // Function to update emotion translations in the data
        function updateEmotionTranslations() {
            const lang = translations[currentLanguage];
            
            // Update emotion names
            emotions.forEach(emotion => {
                const baseKey = emotion.name;
                emotion.translatedName = lang[baseKey] || emotion.name;
                emotion.translatedDescription = lang[baseKey.toLowerCase() + '-description'] || emotion.description;
                emotion.translatedSoundDescription = lang[baseKey.toLowerCase() + '-sound'] || emotion.soundDescription;
            });
            
            // Refresh current screen if needed
            const activeScreen = document.querySelector('.game-screen.active');
            if (activeScreen) {
                if (activeScreen.id === 'flashcards-screen') {
                    updateFlashcard();
                } else if (activeScreen.id === 'soundboard-screen') {
                    initSoundboard();
                } else if (activeScreen.id === 'matching-screen') {
                    // Refresh matching game drop zones with translated names
                    refreshMatchingGameTranslations();
                } else if (activeScreen.id === 'quiz-screen') {
                    // Refresh quiz with translated emotion name
                    refreshQuizTranslations();
                }
            }
        }
        
        // Function to refresh matching game translations
        function refreshMatchingGameTranslations() {
            const dropZones = document.querySelectorAll('.drop-zone:not(.matched)');
            dropZones.forEach(zone => {
                const emotionName = zone.dataset.emotion;
                const emotion = emotions.find(e => e.name === emotionName);
                if (emotion) {
                    // Clear and recreate content with voice button
                    zone.innerHTML = '';
                    
                    const textSpan = document.createElement('span');
                    textSpan.textContent = emotion.translatedName;
                    textSpan.className = 'emotion-text';
                    
                    const voiceBtn = document.createElement('button');
                    voiceBtn.className = 'voice-button';
                    voiceBtn.title = 'Listen';
                    voiceBtn.textContent = 'üîä';
                    voiceBtn.onclick = (e) => {
                        e.stopPropagation();
                        speakEmotionName(emotionName, voiceBtn);
                    };
                    
                    zone.appendChild(textSpan);
                    zone.appendChild(voiceBtn);
                }
            });
            
            // Also update matched drop zones that have text nodes
            const matchedZones = document.querySelectorAll('.drop-zone.matched');
            matchedZones.forEach(zone => {
                const emotionName = zone.dataset.emotion;
                const emotion = emotions.find(e => e.name === emotionName);
                if (emotion) {
                    // Find the text node and update it
                    const textNodes = Array.from(zone.childNodes).filter(node => node.nodeType === Node.TEXT_NODE);
                    if (textNodes.length > 0) {
                        textNodes[0].textContent = emotion.translatedName;
                    }
                }
            });
        }
        
        // Function to refresh quiz translations
        function refreshQuizTranslations() {
            if (currentQuestionIndex < quizQuestions.length) {
                const question = quizQuestions[currentQuestionIndex];
                const emotion = emotions.find(e => e.name === question.emotion);
                if (emotion) {
                    // Update quiz prompt with voice button
                    const quizPrompt = document.querySelector('.quiz-prompt');
                    quizPrompt.innerHTML = `
                        ${emotion.translatedName}
                        <button class="voice-button" onclick="speakEmotionName('${question.emotion}', this)" title="Listen">üîä</button>
                    `;
                }
                
                // Update Yes/No options if question hasn't been answered yet
                if (!questionAnswered) {
                    const options = document.querySelectorAll('.quiz-option');
                    options.forEach(option => {
                        const optionValue = option.dataset.value;
                        if (optionValue && yesNoTranslations[currentLanguage][optionValue]) {
                            option.textContent = yesNoTranslations[currentLanguage][optionValue];
                        }
                    });
                }
            }
        }

        // Language configuration
        const languageConfig = {
            en: {
                code: 'en-US',
                name: 'English'
            },
            ms: {
                code: 'ms-MY',
                name: 'Bahasa Melayu'
            },
            zh: {
                code: 'zh-CN',
                name: '‰∏≠Êñá'
            }
        };

        // Helper function to get language code for TTS
        function getLanguageCode() {
            return languageConfig[currentLanguage]?.code || 'en-US';
        }

        // Text-to-Speech function
        function speakText(elementId) {
            const element = document.getElementById(elementId);
            if (!element) return;
            
            // Get text content - find text nodes and concatenate them
            let text = '';
            for (let node of element.childNodes) {
                if (node.nodeType === Node.TEXT_NODE) {
                    text += node.textContent;
                }
            }
            text = text.trim();
            
            if (!text) return;
            
            // Stop any ongoing speech
            window.speechSynthesis.cancel();
            
            // Create utterance
            const utterance = new SpeechSynthesisUtterance(text);
            utterance.lang = getLanguageCode();
            utterance.rate = 0.9;
            utterance.pitch = 1;
            
            // Visual feedback
            const voiceButtons = element.querySelectorAll('.voice-button');
            voiceButtons.forEach(btn => {
                btn.classList.add('playing');
            });
            
            // Reset UI state on completion or error
            const resetButtons = () => {
                voiceButtons.forEach(btn => {
                    btn.classList.remove('playing');
                });
            };
            
            utterance.onend = resetButtons;
            utterance.onerror = (event) => {
                console.warn('Speech synthesis error:', event.error);
                resetButtons();
            };
            
            window.speechSynthesis.speak(utterance);
        }

        // Function to speak custom text
        function speakCustomText(text) {
            if (!text) return;
            
            // Stop any ongoing speech
            window.speechSynthesis.cancel();
            
            // Create utterance
            const utterance = new SpeechSynthesisUtterance(text);
            utterance.lang = getLanguageCode();
            utterance.rate = 0.9;
            utterance.pitch = 1;
            
            window.speechSynthesis.speak(utterance);
        }

        // Function to speak an emotion name with TTS
        function speakEmotionName(emotionName, buttonElement) {
            const emotion = emotions.find(e => e.name === emotionName);
            if (!emotion) return;
            
            const text = emotion.translatedName;
            if (!text) return;
            
            // Stop any ongoing speech
            window.speechSynthesis.cancel();
            
            // Create utterance
            const utterance = new SpeechSynthesisUtterance(text);
            utterance.lang = getLanguageCode();
            utterance.rate = 0.9;
            utterance.pitch = 1;
            
            // Visual feedback
            if (buttonElement) {
                buttonElement.classList.add('playing');
                
                const resetButton = () => {
                    buttonElement.classList.remove('playing');
                };
                
                utterance.onend = resetButton;
                utterance.onerror = (event) => {
                    console.warn('Speech synthesis error:', event.error);
                    resetButton();
                };
            }
            
            window.speechSynthesis.speak(utterance);
        }

        // Function to return to module menu (placeholder - could navigate to parent page)
        function returnToModuleMenu() {
            // Show a styled notification instead of alert
            const messages = {
                en: 'Returning to Module Menu...',
                ms: 'Kembali ke Menu Modul...',
                zh: 'ËøîÂõûÊ®°ÂùóËèúÂçï...'
            };
            
            // Create and show a toast notification
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: linear-gradient(135deg, #43e97b, #38f9d7);
                color: white;
                padding: 20px 40px;
                border-radius: 15px;
                font-size: 1.2rem;
                font-weight: bold;
                box-shadow: 0 10px 30px rgba(67, 233, 123, 0.4);
                z-index: 10000;
                animation: fadeIn 0.3s ease-in-out;
            `;
            notification.textContent = messages[currentLanguage];
            document.body.appendChild(notification);
            
            // Remove notification after 2 seconds
            setTimeout(() => {
                notification.style.animation = 'fadeOut 0.3s ease-in-out';
                setTimeout(() => notification.remove(), 300);
            }, 2000);
            
            // In a real implementation, this might navigate to a parent page:
            // window.location.href = '../module-menu.html';
        }

        // Human-style emotion data with realistic SVG faces
        const emotions = [
            {
                name: "Happy",
                description: "A feeling of joy and contentment. You might feel happy when something good happens!",
                soundDescription: "Laughing and cheerful voice",
                color: "#FFD93D"
            },
            {
                name: "Sad",
                description: "A feeling of sorrow or unhappiness. People feel sad when something disappointing happens.",
                soundDescription: "Soft crying and sighing",
                color: "#6C9BCF"
            },
            {
                name: "Angry",
                description: "A strong feeling of displeasure. You might feel angry when something unfair happens.",
                soundDescription: "Frustrated and upset voice",
                color: "#FF6B6B"
            },
            {
                name: "Surprised",
                description: "A feeling when something unexpected happens. Surprise can be good or bad!",
                soundDescription: "Gasping with amazement",
                color: "#A8E6CF"
            },
            {
                name: "Scared",
                description: "A feeling of fear or worry. People feel scared when they sense danger.",
                soundDescription: "Nervous and frightened voice",
                color: "#B4A7D6"
            },
            {
                name: "Excited",
                description: "A feeling of enthusiasm and energy. You feel excited when looking forward to something!",
                soundDescription: "Energetic and enthusiastic voice",
                color: "#FFB6C1"
            }
        ];
        
        // Initialize translated properties
        emotions.forEach(emotion => {
            emotion.translatedName = emotion.name;
            emotion.translatedDescription = emotion.description;
            emotion.translatedSoundDescription = emotion.soundDescription;
        });

        // Game state
        let currentCardIndex = 0;
        let isCardFlipped = false;
        let matchingScore = 0;
        let matchesFound = 0;
        let draggedElement = null;
        let quizScore = 0;
        let currentQuestionIndex = 0;
        let quizQuestions = [];
        let questionAnswered = false;
        let audioContext = null;
        let usedQuizEmotions = [];
        let currentAudio = null;  // Track currently playing audio

        // Sound file mappings for each emotion
        const soundFiles = {
            "Happy": "soundeffect/happy-noisesmp3-14568.mp3",
            "Sad": "soundeffect/baby-crying-64996.mp3",
            "Angry": "soundeffect/angry-grunt-103204.mp3",
            "Surprised": "soundeffect/wow1-83641.mp3",
            "Scared": "soundeffect/Kid Screaming.mp3",
            "Excited": "soundeffect/children-saying-yay-praise-and-worship-jesus-299607.mp3"
        };

        // Default config
        const defaultConfig = {
            game_title: "Emotion Learning Game",
            welcome_message: "Learn to recognize and name emotions!",
            flashcard_button: "üé¥ Flashcards",
            matching_button: "üéØ Matching Game",
            quiz_button: "üß† Expression Quiz",
            soundboard_button: "üé§ Voice Soundboard",
            background_color: "#667eea",
            surface_color: "#ffffff",
            text_color: "#2d3748",
            primary_action: "#667eea",
            secondary_action: "#764ba2",
            font_family: "Segoe UI",
            font_size: 16
        };

        // Element SDK implementation
        const element = {
            defaultConfig: defaultConfig,
            onConfigChange: async (config) => {
                document.getElementById('game-title').textContent = config.game_title || defaultConfig.game_title;
                document.getElementById('welcome-message').textContent = config.welcome_message || defaultConfig.welcome_message;
                document.getElementById('flashcard-btn').textContent = config.flashcard_button || defaultConfig.flashcard_button;
                document.getElementById('matching-btn').textContent = config.matching_button || defaultConfig.matching_button;
                document.getElementById('quiz-btn').textContent = config.quiz_button || defaultConfig.quiz_button;
                document.getElementById('soundboard-btn').textContent = config.soundboard_button || defaultConfig.soundboard_button;

                const backgroundColor = config.background_color || defaultConfig.background_color;
                const surfaceColor = config.surface_color || defaultConfig.surface_color;
                const textColor = config.text_color || defaultConfig.text_color;

                document.body.style.background = `linear-gradient(135deg, ${backgroundColor} 0%, #764ba2 100%)`;
                document.querySelector('.container').style.backgroundColor = surfaceColor;
                document.querySelector('.container').style.color = textColor;

                const customFont = config.font_family || defaultConfig.font_family;
                const baseSize = config.font_size || defaultConfig.font_size;
                document.body.style.fontFamily = `${customFont}, sans-serif`;
                document.body.style.fontSize = `${baseSize}px`;
                
                document.querySelector('.title').style.fontSize = `${baseSize * 2.8}px`;
                document.querySelector('.subtitle').style.fontSize = `${baseSize * 1.3}px`;
            },
            mapToCapabilities: (config) => ({
                recolorables: [
                    {
                        get: () => config.background_color || defaultConfig.background_color,
                        set: (value) => {
                            if (window.elementSdk) {
                                window.elementSdk.setConfig({ background_color: value });
                            }
                        }
                    },
                    {
                        get: () => config.surface_color || defaultConfig.surface_color,
                        set: (value) => {
                            if (window.elementSdk) {
                                window.elementSdk.setConfig({ surface_color: value });
                            }
                        }
                    },
                    {
                        get: () => config.text_color || defaultConfig.text_color,
                        set: (value) => {
                            if (window.elementSdk) {
                                window.elementSdk.setConfig({ text_color: value });
                            }
                        }
                    },
                    {
                        get: () => config.primary_action || defaultConfig.primary_action,
                        set: (value) => {
                            if (window.elementSdk) {
                                window.elementSdk.setConfig({ primary_action: value });
                            }
                        }
                    },
                    {
                        get: () => config.secondary_action || defaultConfig.secondary_action,
                        set: (value) => {
                            if (window.elementSdk) {
                                window.elementSdk.setConfig({ secondary_action: value });
                            }
                        }
                    }
                ],
                borderables: [],
                fontEditable: {
                    get: () => config.font_family || defaultConfig.font_family,
                    set: (value) => {
                        if (window.elementSdk) {
                            window.elementSdk.setConfig({ font_family: value });
                        }
                    }
                },
                fontSizeable: {
                    get: () => config.font_size || defaultConfig.font_size,
                    set: (value) => {
                        if (window.elementSdk) {
                            window.elementSdk.setConfig({ font_size: value });
                        }
                    }
                }
            }),
            mapToEditPanelValues: (config) => new Map([
                ["game_title", config.game_title || defaultConfig.game_title],
                ["welcome_message", config.welcome_message || defaultConfig.welcome_message],
                ["flashcard_button", config.flashcard_button || defaultConfig.flashcard_button],
                ["matching_button", config.matching_button || defaultConfig.matching_button],
                ["quiz_button", config.quiz_button || defaultConfig.quiz_button],
                ["soundboard_button", config.soundboard_button || defaultConfig.soundboard_button]
            ])
        };

        // Initialize SDK
        if (window.elementSdk) {
            window.elementSdk.init(element);
        }

        // Function to draw human-like faces with SVG
        function drawHumanFace(svgElement, emotionName) {
            const emotion = emotions.find(e => e.name === emotionName);
            const color = emotion ? emotion.color : "#FFD93D";
            
            svgElement.innerHTML = '';
            
            // Face circle
            const face = document.createElementNS("http://www.w3.org/2000/svg", "circle");
            face.setAttribute("cx", "100");
            face.setAttribute("cy", "100");
            face.setAttribute("r", "90");
            face.setAttribute("fill", color);
            face.setAttribute("stroke", "#2d3748");
            face.setAttribute("stroke-width", "3");
            svgElement.appendChild(face);

            // Draw features based on emotion
            switch(emotionName) {
                case "Happy":
                    const smile = document.createElementNS("http://www.w3.org/2000/svg", "image");
                    smile.setAttribute("href", "assets/happy.png"); // adjust to your actual path
                    smile.setAttributeNS("http://www.w3.org/1999/xlink", "href", "assets/happy.png");
                    smile.setAttribute("x", "10");
                    smile.setAttribute("y", "10");
                    smile.setAttribute("width", "180");
                    smile.setAttribute("height", "180");
                    smile.setAttribute("preserveAspectRatio", "xMidYMid meet");
                    svgElement.appendChild(smile);

                    const title_happy = document.createElementNS("http://www.w3.org/2000/svg", "title");
                    title_happy.textContent = "Happy";
                    svgElement.appendChild(title_happy);
                    break;

                case "Sad":
                    // Tears
                    const tear1 = document.createElementNS("http://www.w3.org/2000/svg", "image");
                    tear1.setAttribute("href", "assets/sad.png"); // adjust to your actual path
                    tear1.setAttributeNS("http://www.w3.org/1999/xlink", "href", "assets/sad.png");
                    tear1.setAttribute("x", "10");
                    tear1.setAttribute("y", "10");
                    tear1.setAttribute("width", "180");
                    tear1.setAttribute("height", "180");
                    tear1.setAttribute("preserveAspectRatio", "xMidYMid meet");
                    svgElement.appendChild(tear1);

                    const title_sad = document.createElementNS("http://www.w3.org/2000/svg", "title");
                    title_sad.textContent = "Sad";
                    svgElement.appendChild(title_sad);
                    break;

                case "Angry":
                    // Angry eyebrows 
                    const brow1 = document.createElementNS("http://www.w3.org/2000/svg", "image");
                    brow1.setAttribute("href", "assets/angry.png"); // adjust to your actual path
                    brow1.setAttributeNS("http://www.w3.org/1999/xlink", "href", "assets/angry.png");
                    brow1.setAttribute("x", "10");
                    brow1.setAttribute("y", "10");
                    brow1.setAttribute("width", "180");
                    brow1.setAttribute("height", "180");
                    brow1.setAttribute("preserveAspectRatio", "xMidYMid meet");
                    svgElement.appendChild(brow1);

                    const title_angry = document.createElementNS("http://www.w3.org/2000/svg", "title");
                    title_angry.textContent = "Angry";
                    svgElement.appendChild(title_angry);
                    break;

                case "Surprised":
                    const img_surprised = document.createElementNS("http://www.w3.org/2000/svg", "image");
                    img_surprised.setAttribute("href", "assets/surprised.png"); // adjust to your actual path
                    img_surprised.setAttributeNS("http://www.w3.org/1999/xlink", "href", "assets/surprised.png");
                    img_surprised.setAttribute("x", "10");
                    img_surprised.setAttribute("y", "10");
                    img_surprised.setAttribute("width", "180");
                    img_surprised.setAttribute("height", "180");
                    img_surprised.setAttribute("preserveAspectRatio", "xMidYMid meet");
                    svgElement.appendChild(img_surprised);

                    const title_surprised = document.createElementNS("http://www.w3.org/2000/svg", "title");
                    title_surprised.textContent = "Surprised";
                    svgElement.appendChild(title_surprised);
                    break;

                case "Scared":
                    const img = document.createElementNS("http://www.w3.org/2000/svg", "image");
                    img.setAttribute("href", "assets/scared.png"); // adjust to your actual path
                    img.setAttributeNS("http://www.w3.org/1999/xlink", "href", "assets/scared.png");
                    img.setAttribute("x", "10");
                    img.setAttribute("y", "10");
                    img.setAttribute("width", "180");
                    img.setAttribute("height", "180");
                    img.setAttribute("preserveAspectRatio", "xMidYMid meet");
                    svgElement.appendChild(img);

                    const title = document.createElementNS("http://www.w3.org/2000/svg", "title");
                    title.textContent = "Scared";
                    svgElement.appendChild(title);
                    break;

                case "Excited":
                    const img_excited = document.createElementNS("http://www.w3.org/2000/svg", "image");
                    img_excited.setAttribute("href", "assets/excited.png"); // adjust to your actual path
                    img_excited.setAttributeNS("http://www.w3.org/1999/xlink", "href", "assets/excited.png");
                    img_excited.setAttribute("x", "10");
                    img_excited.setAttribute("y", "10");
                    img_excited.setAttribute("width", "180");
                    img_excited.setAttribute("height", "180");
                    img_excited.setAttribute("preserveAspectRatio", "xMidYMid meet");
                    svgElement.appendChild(img_excited);

                    const title_excited = document.createElementNS("http://www.w3.org/2000/svg", "title");
                    title_excited.textContent = "Excited";
                    svgElement.appendChild(title_excited);
                    break;
            }
        }

        function drawEye(svg, x, y, happy = false, wide = false) {
            if (happy) {
                // Happy eyes (curved)
                const eye = document.createElementNS("http://www.w3.org/2000/svg", "path");
                eye.setAttribute("d", `M ${x-10} ${y} Q ${x} ${y+8} ${x+10} ${y}`);
                eye.setAttribute("stroke", "#2d3748");
                eye.setAttribute("stroke-width", "3");
                eye.setAttribute("fill", "none");
                eye.setAttribute("stroke-linecap", "round");
                svg.appendChild(eye);
            } else if (wide) {
                // Wide eyes
                const eye = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                eye.setAttribute("cx", x);
                eye.setAttribute("cy", y);
                eye.setAttribute("r", "10");
                eye.setAttribute("fill", "white");
                eye.setAttribute("stroke", "#2d3748");
                eye.setAttribute("stroke-width", "3");
                svg.appendChild(eye);
                
                const pupil = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                pupil.setAttribute("cx", x);
                pupil.setAttribute("cy", y);
                pupil.setAttribute("r", "5");
                pupil.setAttribute("fill", "#2d3748");
                svg.appendChild(pupil);
            } else {
                // Normal eyes
                const eye = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                eye.setAttribute("cx", x);
                eye.setAttribute("cy", y);
                eye.setAttribute("r", "8");
                eye.setAttribute("fill", "white");
                eye.setAttribute("stroke", "#2d3748");
                eye.setAttribute("stroke-width", "2");
                svg.appendChild(eye);
                
                const pupil = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                pupil.setAttribute("cx", x);
                pupil.setAttribute("cy", y);
                pupil.setAttribute("r", "4");
                pupil.setAttribute("fill", "#2d3748");
                svg.appendChild(pupil);
            }
        }

        function drawSparkle(svg, x, y) {
            const sparkle = document.createElementNS("http://www.w3.org/2000/svg", "path");
            sparkle.setAttribute("d", `M ${x} ${y-6} L ${x} ${y+6} M ${x-6} ${y} L ${x+6} ${y}`);
            sparkle.setAttribute("stroke", "#FFD700");
            sparkle.setAttribute("stroke-width", "2");
            sparkle.setAttribute("stroke-linecap", "round");
            svg.appendChild(sparkle);
        }

        // Initialize audio context
        function initAudioContext() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
        }

        // Navigation functions
        function showMainMenu() {
            hideAllScreens();
            document.getElementById('main-menu').classList.add('active');
        }

        function showFlashcards() {
            hideAllScreens();
            document.getElementById('flashcards-screen').classList.add('active');
            currentCardIndex = 0;
            updateFlashcard();
        }

        function showMatchingGame() {
            hideAllScreens();
            document.getElementById('matching-screen').classList.add('active');
            initMatchingGame();
        }

        function showQuiz() {
            hideAllScreens();
            document.getElementById('quiz-screen').classList.add('active');
            initQuiz();
        }

        function showSoundboard() {
            hideAllScreens();
            document.getElementById('soundboard-screen').classList.add('active');
            initSoundboard();
        }

        function showFacialRecognition() {
            hideAllScreens();
            document.getElementById('facial-screen').classList.add('active');
            updateFacialRecognitionUI();
        }

        function hideAllScreens() {
            document.querySelectorAll('.game-screen').forEach(screen => {
                screen.classList.remove('active');
            });
        }

        // Flashcard functions
        function updateFlashcard() {
            const emotion = emotions[currentCardIndex];
            const faceSvg = document.getElementById('card-face');
            drawHumanFace(faceSvg, emotion.name);
            
            // Update emotion name with voice button
            const emotionNameEl = document.getElementById('card-emotion-name');
            emotionNameEl.innerHTML = `
                ${emotion.translatedName}
                <button class="voice-button" onclick="event.stopPropagation(); speakEmotionName('${emotion.name}', this)" title="Listen">üîä</button>
            `;
            
            document.getElementById('flashcard').classList.remove('flipped');
            isCardFlipped = false;
        }

        function flipCard() {
            const card = document.getElementById('flashcard');
            card.classList.toggle('flipped');
            isCardFlipped = !isCardFlipped;
        }

        function nextCard() {
            currentCardIndex = (currentCardIndex + 1) % emotions.length;
            updateFlashcard();
        }

        function previousCard() {
            currentCardIndex = (currentCardIndex - 1 + emotions.length) % emotions.length;
            updateFlashcard();
        }

        // Drag and Drop Matching Game functions
        let touchedElement = null;
        let touchClone = null;
        
        function initMatchingGame() {
            matchingScore = 0;
            matchesFound = 0;
            
            // Reset touch state variables
            touchedElement = null;
            if (touchClone) {
                touchClone.remove();
                touchClone = null;
            }
            
            const emojiGrid = document.getElementById('emoji-grid');
            emojiGrid.innerHTML = '';
            
            const shuffledEmotions = shuffleArray([...emotions]);
            shuffledEmotions.forEach((emotion, index) => {
                const emojiElement = document.createElement('div');
                emojiElement.className = 'draggable-emoji';
                emojiElement.draggable = true;
                emojiElement.dataset.emotion = emotion.name;
                
                const faceSvg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
                faceSvg.setAttribute("class", "draggable-face");
                faceSvg.setAttribute("viewBox", "0 0 200 200");
                drawHumanFace(faceSvg, emotion.name);
                
                emojiElement.appendChild(faceSvg);
                
                // Desktop drag and drop
                emojiElement.addEventListener('dragstart', handleDragStart);
                emojiElement.addEventListener('dragend', handleDragEnd);
                
                // Mobile touch events
                emojiElement.addEventListener('touchstart', handleTouchStart, { passive: false });
                emojiElement.addEventListener('touchmove', handleTouchMove, { passive: false });
                emojiElement.addEventListener('touchend', handleTouchEnd, { passive: false });
                
                emojiGrid.appendChild(emojiElement);
            });
            
            const namesGrid = document.getElementById('names-grid');
            namesGrid.innerHTML = '';
            
            const shuffledNames = shuffleArray(emotions.map(e => ({ name: e.name, translatedName: e.translatedName })));
            shuffledNames.forEach(emotionData => {
                const dropZone = document.createElement('div');
                dropZone.className = 'drop-zone';
                dropZone.dataset.emotion = emotionData.name;
                
                // Create text span and voice button
                const textSpan = document.createElement('span');
                textSpan.textContent = emotionData.translatedName;
                textSpan.className = 'emotion-text';
                
                const voiceBtn = document.createElement('button');
                voiceBtn.className = 'voice-button';
                voiceBtn.title = 'Listen';
                voiceBtn.textContent = 'üîä';
                voiceBtn.onclick = (e) => {
                    e.stopPropagation();
                    speakEmotionName(emotionData.name, voiceBtn);
                };
                
                dropZone.appendChild(textSpan);
                dropZone.appendChild(voiceBtn);
                
                dropZone.addEventListener('dragover', handleDragOver);
                dropZone.addEventListener('drop', handleDrop);
                dropZone.addEventListener('dragleave', handleDragLeave);
                
                namesGrid.appendChild(dropZone);
            });
            
            updateMatchingScore();
        }

        function handleDragStart(e) {
            draggedElement = e.target;
            e.target.classList.add('dragging');
        }

        function handleDragEnd(e) {
            e.target.classList.remove('dragging');
            draggedElement = null;
        }

        function handleSuccessfulMatch(dropZone, draggedElement, targetEmotion) {
            dropZone.classList.add('matched');
            const faceSvg = draggedElement.querySelector('svg').cloneNode(true);
            faceSvg.style.width = '50px';
            faceSvg.style.height = '50px';
            faceSvg.style.display = 'inline-block';
            faceSvg.style.marginRight = '10px';
            dropZone.innerHTML = '';
            dropZone.appendChild(faceSvg);
            
            // Find the translated name for the emotion
            const emotion = emotions.find(e => e.name === targetEmotion);
            const displayText = emotion ? emotion.translatedName : targetEmotion;
            dropZone.appendChild(document.createTextNode(displayText));
            draggedElement.style.display = 'none';
            
            matchingScore += 10;
            matchesFound++;
            playSuccessSound();
            
            if (matchesFound === 6) {
                setTimeout(() => {
                    const messages = {
                        en: 'Amazing! You matched all emotions! üåü',
                        ms: 'Hebat! Anda telah memasangkan semua emosi! üåü',
                        zh: 'Â§™Ê£í‰∫ÜÔºÅ‰Ω†ÂåπÈÖç‰∫ÜÊâÄÊúâÊÉÖÁª™ÔºÅüåü'
                    };
                    showCompletionMessage(messages[currentLanguage]);
                }, 500);
            }
            
            updateMatchingScore();
        }

        function handleTouchStart(e) {
            e.preventDefault();
            touchedElement = e.target.closest('.draggable-emoji');
            if (!touchedElement) return;
            
            const touch = e.touches[0];
            
            touchedElement.classList.add('dragging');
            
            // Create a clone for visual feedback
            touchClone = touchedElement.cloneNode(true);
            touchClone.style.position = 'fixed';
            touchClone.style.pointerEvents = 'none';
            touchClone.style.zIndex = '1000';
            touchClone.style.opacity = '0.8';
            touchClone.style.width = touchedElement.offsetWidth + 'px';
            touchClone.style.height = touchedElement.offsetHeight + 'px';
            touchClone.style.left = (touch.clientX - touchedElement.offsetWidth / 2) + 'px';
            touchClone.style.top = (touch.clientY - touchedElement.offsetHeight / 2) + 'px';
            document.body.appendChild(touchClone);
        }

        function handleTouchMove(e) {
            e.preventDefault();
            if (!touchedElement || !touchClone) return;
            
            const touch = e.touches[0];
            touchClone.style.left = (touch.clientX - touchedElement.offsetWidth / 2) + 'px';
            touchClone.style.top = (touch.clientY - touchedElement.offsetHeight / 2) + 'px';
            
            // Highlight drop zones when hovering over them
            const dropZones = document.querySelectorAll('.drop-zone');
            dropZones.forEach(zone => {
                zone.classList.remove('drag-over');
            });
            
            const elemBelow = document.elementFromPoint(touch.clientX, touch.clientY);
            const dropZone = elemBelow?.closest('.drop-zone');
            if (dropZone && !dropZone.classList.contains('matched')) {
                dropZone.classList.add('drag-over');
            }
        }

        function handleTouchEnd(e) {
            e.preventDefault();
            if (!touchedElement) return;
            
            const touch = e.changedTouches[0];
            const elemBelow = document.elementFromPoint(touch.clientX, touch.clientY);
            const dropZone = elemBelow?.closest('.drop-zone');
            
            // Clean up visual feedback
            if (touchClone) {
                touchClone.remove();
                touchClone = null;
            }
            
            touchedElement.classList.remove('dragging');
            
            // Remove drag-over class from all drop zones
            const dropZones = document.querySelectorAll('.drop-zone');
            dropZones.forEach(zone => {
                zone.classList.remove('drag-over');
            });
            
            // Check if dropped on a valid drop zone
            if (dropZone && !dropZone.classList.contains('matched')) {
                const draggedEmotion = touchedElement.dataset.emotion;
                const targetEmotion = dropZone.dataset.emotion;
                
                if (draggedEmotion === targetEmotion) {
                    handleSuccessfulMatch(dropZone, touchedElement, targetEmotion);
                } else {
                    dropZone.classList.add('wrong');
                    setTimeout(() => {
                        dropZone.classList.remove('wrong');
                    }, 500);
                }
            }
            
            touchedElement = null;
        }

        function handleDragOver(e) {
            e.preventDefault();
            e.target.classList.add('drag-over');
        }

        function handleDragLeave(e) {
            e.target.classList.remove('drag-over');
        }

        function handleDrop(e) {
            e.preventDefault();
            e.target.classList.remove('drag-over');
            
            if (!draggedElement || e.target.classList.contains('matched')) {
                return;
            }
            
            const draggedEmotion = draggedElement.dataset.emotion;
            const targetEmotion = e.target.dataset.emotion;
            
            if (draggedEmotion === targetEmotion) {
                handleSuccessfulMatch(e.target, draggedElement, targetEmotion);
            } else {
                e.target.classList.add('wrong');
                setTimeout(() => {
                    e.target.classList.remove('wrong');
                }, 500);
            }
        }

        function updateMatchingScore() {
            document.getElementById('matching-score').textContent = matchingScore;
            document.getElementById('matches-count').textContent = matchesFound;
        }

        function resetMatchingGame() {
            initMatchingGame();
        }

        // Quiz functions
        function initQuiz() {
            quizScore = 0;
            currentQuestionIndex = 0;
            questionAnswered = false;
            usedQuizEmotions = [];
            
            // Generate 10 quiz questions with shuffled emotions
            quizQuestions = [];
            
            // Create a pool of emotions for 10 questions by repeating and shuffling
            let emotionPool = [];
            
            // First pass: add all emotions shuffled
            let shuffledEmotions = shuffleArray([...emotions]);
            emotionPool = emotionPool.concat(shuffledEmotions);
            
            // Second pass: add remaining needed emotions shuffled
            if (emotionPool.length < 10) {
                shuffledEmotions = shuffleArray([...emotions]);
                const additionalNeeded = 10 - emotionPool.length;
                emotionPool = emotionPool.concat(shuffledEmotions.slice(0, additionalNeeded));
            }
            
            // Build questions from the emotion pool
            for (let i = 0; i < 10; i++) {
                const correctEmotion = emotionPool[i];
                
                quizQuestions.push({
                    emotion: correctEmotion.name,
                    correct: "Yes",
                    options: ["Yes", "No"]
                });
            }
            
            showQuestion();
        }

        function showQuestion() {
            const question = quizQuestions[currentQuestionIndex];
            const faceSvg = document.getElementById('quiz-face');
            drawHumanFace(faceSvg, question.emotion);
            
            document.getElementById('question-number').textContent = currentQuestionIndex + 1;
            document.getElementById('quiz-score').textContent = quizScore;
            
            // Find the emotion to get translated name
            const emotion = emotions.find(e => e.name === question.emotion);
            const translatedEmotionName = emotion ? emotion.translatedName : question.emotion;
            
            // Update the quiz prompt to show the translated emotion word with voice button
            const quizPrompt = document.querySelector('.quiz-prompt');
            quizPrompt.innerHTML = `
                ${translatedEmotionName}
                <button class="voice-button" onclick="speakEmotionName('${question.emotion}', this)" title="Listen">üîä</button>
            `;
            
            const optionsContainer = document.getElementById('quiz-options');
            optionsContainer.innerHTML = '';
            
            question.options.forEach(option => {
                const button = document.createElement('button');
                button.className = 'quiz-option';
                button.textContent = yesNoTranslations[currentLanguage][option];
                button.dataset.value = option;
                button.onclick = () => selectAnswer(option, question.correct);
                optionsContainer.appendChild(button);
            });
            
            document.getElementById('quiz-feedback').textContent = '';
            document.getElementById('quiz-feedback').className = 'quiz-feedback';
            document.getElementById('next-question').disabled = true;
            questionAnswered = false;
        }

        function selectAnswer(selected, correct) {
            if (questionAnswered) return;
            
            questionAnswered = true;
            const options = document.querySelectorAll('.quiz-option');
            const feedback = document.getElementById('quiz-feedback');
            
            options.forEach(option => {
                const optionValue = option.dataset.value;
                if (optionValue === correct) {
                    option.classList.add('correct');
                } else if (optionValue === selected && selected !== correct) {
                    option.classList.add('incorrect');
                }
                option.onclick = null;
            });
            
            const feedbackMessages = {
                correct: {
                    en: 'Correct! Great job recognizing that emotion! üåü',
                    ms: 'Betul! Syabas kerana mengenali emosi itu! üåü',
                    zh: 'Ê≠£Á°ÆÔºÅÂæàÂ•ΩÂú∞ËØÜÂà´‰∫ÜÈÇ£ÁßçÊÉÖÁª™ÔºÅüåü'
                },
                incorrect: {
                    en: 'Not quite! The correct answer is {answer}. Keep learning! üí™',
                    ms: 'Tidak tepat! Jawapan yang betul ialah {answer}. Terus belajar! üí™',
                    zh: '‰∏çÂ§™ÂØπÔºÅÊ≠£Á°ÆÁ≠îÊ°àÊòØ{answer}„ÄÇÁªßÁª≠Â≠¶‰π†ÔºÅüí™'
                }
            };
            
            if (selected === correct) {
                quizScore += 10;
                feedback.textContent = feedbackMessages.correct[currentLanguage];
                feedback.className = 'quiz-feedback correct';
                playSuccessSound();
            } else {
                const translatedAnswer = yesNoTranslations[currentLanguage][correct];
                feedback.textContent = feedbackMessages.incorrect[currentLanguage].replace('{answer}', translatedAnswer);
                feedback.className = 'quiz-feedback incorrect';
            }
            
            document.getElementById('quiz-score').textContent = quizScore;
            document.getElementById('next-question').disabled = false;
        }

        function nextQuestion() {
            currentQuestionIndex++;
            
            if (currentQuestionIndex >= quizQuestions.length) {
                const optionsContainer = document.getElementById('quiz-options');
                optionsContainer.innerHTML = '';
                
                const feedback = document.getElementById('quiz-feedback');
                const percentage = (quizScore / 100) * 100;
                
                const completionMessages = {
                    en: {
                        title: 'Quiz Completed! üéâ',
                        score: 'Final Score: {score}/100 ({percentage}%)',
                        excellent: "üåü You're an emotion recognition expert!",
                        good: 'üëç Great job learning emotions!',
                        practice: 'üí™ Keep practicing to improve!'
                    },
                    ms: {
                        title: 'Kuiz Selesai! üéâ',
                        score: 'Skor Akhir: {score}/100 ({percentage}%)',
                        excellent: 'üåü Anda pakar mengenali emosi!',
                        good: 'üëç Bagus! Terus belajar emosi!',
                        practice: 'üí™ Terus berlatih untuk meningkatkan!'
                    },
                    zh: {
                        title: 'ÊµãÈ™åÂÆåÊàêÔºÅüéâ',
                        score: 'ÊúÄÁªàÂæóÂàÜÔºö{score}/100 ({percentage}%)',
                        excellent: 'üåü ‰Ω†ÊòØÊÉÖÁª™ËØÜÂà´‰∏ìÂÆ∂ÔºÅ',
                        good: 'üëç Â≠¶‰π†ÊÉÖÁª™ÂÅöÂæóÂæàÂ•ΩÔºÅ',
                        practice: 'üí™ ÁªßÁª≠ÁªÉ‰π†‰ª•ÊèêÈ´òÔºÅ'
                    }
                };
                
                const msgs = completionMessages[currentLanguage];
                
                feedback.innerHTML = `
                    <div style="font-size: 1.8rem; margin-bottom: 15px;">${msgs.title}</div>
                    <div style="font-size: 1.4rem;">${msgs.score.replace('{score}', quizScore).replace('{percentage}', percentage)}</div>
                `;
                
                if (percentage >= 80) {
                    feedback.innerHTML += `<div style="margin-top: 10px;">${msgs.excellent}</div>`;
                } else if (percentage >= 60) {
                    feedback.innerHTML += `<div style="margin-top: 10px;">${msgs.good}</div>`;
                } else {
                    feedback.innerHTML += `<div style="margin-top: 10px;">${msgs.practice}</div>`;
                }
                
                feedback.className = 'quiz-feedback correct';
                
                const playAgainText = {
                    en: 'Play Again',
                    ms: 'Main Semula',
                    zh: 'ÂÜçÁé©‰∏ÄÊ¨°'
                };
                
                document.getElementById('next-question').textContent = playAgainText[currentLanguage];
                document.getElementById('next-question').onclick = initQuiz;
                document.getElementById('next-question').disabled = false;
            } else {
                showQuestion();
            }
        }

        // Soundboard functions
        function initSoundboard() {
            initAudioContext();
            const grid = document.getElementById('soundboard-grid');
            grid.innerHTML = '';
            
            emotions.forEach((emotion, index) => {
                const card = document.createElement('div');
                card.className = 'sound-card';
                
                const faceSvg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
                faceSvg.setAttribute("class", "sound-face");
                faceSvg.setAttribute("viewBox", "0 0 200 200");
                drawHumanFace(faceSvg, emotion.name);
                
                const nameDiv = document.createElement('div');
                nameDiv.className = 'sound-name';
                nameDiv.innerHTML = `
                    ${emotion.translatedName}
                    <button class="voice-button" onclick="event.stopPropagation(); speakEmotionName('${emotion.name}', this)" title="Listen">üîä</button>
                `;
                
                const descDiv = document.createElement('div');
                descDiv.className = 'sound-description';
                descDiv.textContent = emotion.translatedSoundDescription;
                
                const playBtn = document.createElement('button');
                playBtn.className = 'play-button';
                const playText = {
                    en: 'üîä Play Voice',
                    ms: 'üîä Main Suara',
                    zh: 'üîä Êí≠ÊîæÂ£∞Èü≥'
                };
                playBtn.textContent = playText[currentLanguage];
                playBtn.onclick = () => playEmotionSound(index);
                
                card.appendChild(faceSvg);
                card.appendChild(nameDiv);
                card.appendChild(descDiv);
                card.appendChild(playBtn);
                
                grid.appendChild(card);
            });
        }

        let currentPlayingIndex = null;  // Track which card is currently playing

        function playEmotionSound(emotionIndex) {
            const emotion = emotions[emotionIndex];
            const card = document.querySelectorAll('.sound-card')[emotionIndex];
            const playButton = card.querySelector('.play-button');
            
            const playingText = {
                en: 'üéµ Playing...',
                ms: 'üéµ Bermain...',
                zh: 'üéµ Êí≠Êîæ‰∏≠...'
            };
            
            const playText = {
                en: 'üîä Play Voice',
                ms: 'üîä Main Suara',
                zh: 'üîä Êí≠ÊîæÂ£∞Èü≥'
            };
            
            // Reset the previously playing card's UI if there is one
            if (currentPlayingIndex !== null && currentPlayingIndex !== emotionIndex) {
                const prevCard = document.querySelectorAll('.sound-card')[currentPlayingIndex];
                const prevButton = prevCard.querySelector('.play-button');
                prevCard.classList.remove('playing');
                prevButton.textContent = playText[currentLanguage];
                prevButton.classList.remove('playing');
            }
            
            currentPlayingIndex = emotionIndex;
            card.classList.add('playing');
            playButton.textContent = playingText[currentLanguage];
            playButton.classList.add('playing');
            
            // Play MP3 sound file based on emotion
            playHumanVoice(emotion.name, () => {
                card.classList.remove('playing');
                playButton.textContent = playText[currentLanguage];
                playButton.classList.remove('playing');
                if (currentPlayingIndex === emotionIndex) {
                    currentPlayingIndex = null;
                }
            });
        }

        function playHumanVoice(emotionName, callback) {
            const soundFile = soundFiles[emotionName];
            if (!soundFile) {
                if (callback) callback();
                return;
            }
            
            // Stop any currently playing audio to prevent overlapping
            if (currentAudio) {
                currentAudio.pause();
                currentAudio.currentTime = 0;
            }
            
            const audio = new Audio(soundFile);
            currentAudio = audio;  // Track the current audio
            
            audio.onended = () => {
                if (currentAudio === audio) {
                    currentAudio = null;
                }
                if (callback) callback();
            };
            audio.onerror = () => {
                console.error('Error loading sound file:', soundFile);
                if (currentAudio === audio) {
                    currentAudio = null;
                }
                if (callback) callback();
            };
            audio.play().catch(err => {
                console.error('Error playing sound:', err);
                if (currentAudio === audio) {
                    currentAudio = null;
                }
                if (callback) callback();
            });
        }

        function playSuccessSound() {
            // TODO: Implement Web Audio API tones for success sound feedback
            // Currently silent to prevent errors - consider adding audio feedback in future
            try {
                if (!audioContext) {
                    initAudioContext();
                }
            } catch (err) {
                console.log('Audio playback not available');
            }
        }

        function showCompletionMessage(message) {
            const messageDiv = document.createElement('div');
            messageDiv.className = 'completion-message';
            messageDiv.textContent = message;
            
            const activeScreen = document.querySelector('.game-screen.active');
            activeScreen.appendChild(messageDiv);
            
            setTimeout(() => {
                messageDiv.remove();
            }, 4000);
        }

        function shuffleArray(array) {
            const shuffled = [...array];
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            return shuffled;
        }

        // Facial Recognition Variables
        let facialModel, facialWebcam, facialMaxPredictions;
        let isFacialRecognitionRunning = false;
        let facialAnimationId = null;
        let isDemoMode = false;
        let lastPredictionTime = 0;

        // Configuration constants
        const FACIAL_MODEL_URL = "./emotion_model/";
        const WEBCAM_WIDTH = 300;
        const WEBCAM_HEIGHT = 300;
        const PREDICTION_FPS = 15; // Limit predictions to 15 FPS to save CPU
        const PREDICTION_INTERVAL = 1000 / PREDICTION_FPS;

        // Demo mode state for more realistic predictions
        let demoPredictions = null;
        let demoTransitionTarget = null;
        let demoTransitionProgress = 0;

        // Update facial recognition UI text based on current language
        function updateFacialRecognitionUI() {
            const lang = translations[currentLanguage];
            
            const startBtn = document.getElementById('start-webcam-btn');
            const stopBtn = document.getElementById('stop-webcam-btn');
            const status = document.getElementById('webcam-status');
            const detectedLabel = document.getElementById('detected-label');
            const predictionTitle = document.getElementById('prediction-title');
            const modelNote = document.getElementById('model-note');
            
            if (startBtn && !isFacialRecognitionRunning) {
                startBtn.textContent = lang['start-camera'];
            }
            if (stopBtn) {
                stopBtn.textContent = lang['stop-camera'];
            }
            if (status && !isFacialRecognitionRunning) {
                status.textContent = lang['webcam-status-ready'];
            }
            if (detectedLabel) {
                detectedLabel.textContent = lang['detected-emotion-label'];
            }
            if (predictionTitle) {
                predictionTitle.textContent = lang['prediction-title'];
            }
            if (modelNote) {
                modelNote.innerHTML = `
                    <strong>${lang['note-label']}</strong> ${lang['model-note']}
                    <br><br>
                    <a href="https://teachablemachine.withgoogle.com/train/image" target="_blank">${lang['model-link']}</a>
                `;
            }
        }

        // Initialize facial recognition with Teachable Machine
        async function initFacialRecognition() {
            const lang = translations[currentLanguage];
            const statusEl = document.getElementById('webcam-status');
            const startBtn = document.getElementById('start-webcam-btn');
            const stopBtn = document.getElementById('stop-webcam-btn');
            
            try {
                // Update status
                statusEl.textContent = lang['webcam-status-loading'];
                statusEl.className = 'webcam-status';
                startBtn.disabled = true;
                isDemoMode = false;
                
                // Load the model and metadata
                const modelURL = FACIAL_MODEL_URL + "model.json";
                const metadataURL = FACIAL_MODEL_URL + "metadata.json";
                
                try {
                    facialModel = await tmImage.load(modelURL, metadataURL);
                    facialMaxPredictions = facialModel.getTotalClasses();
                } catch (modelError) {
                    console.warn('Could not load custom model, using demo mode:', modelError);
                    // Demo mode - simulate emotion detection without a real model
                    facialMaxPredictions = 6;
                    facialModel = null;
                    isDemoMode = true;
                    // Initialize demo predictions with balanced values
                    initDemoPredictions();
                }
                
                // Setup webcam
                const flip = true;
                facialWebcam = new tmImage.Webcam(WEBCAM_WIDTH, WEBCAM_HEIGHT, flip);
                await facialWebcam.setup();
                await facialWebcam.play();
                
                isFacialRecognitionRunning = true;
                lastPredictionTime = 0;
                
                // Append webcam to the DOM
                const webcamContainer = document.getElementById('webcam-container');
                webcamContainer.innerHTML = '';
                webcamContainer.appendChild(facialWebcam.canvas);
                
                // Show prediction containers
                document.getElementById('detected-emotion-display').style.display = 'block';
                document.getElementById('prediction-container').style.display = 'block';
                
                // Initialize label container
                initializePredictionLabels();
                
                // Update UI with demo mode indicator if applicable
                if (isDemoMode) {
                    const demoMessages = {
                        en: 'Demo Mode - No model loaded. Add your Teachable Machine model for real detection.',
                        ms: 'Mod Demo - Tiada model dimuatkan. Tambah model Teachable Machine anda untuk pengesanan sebenar.',
                        zh: 'ÊºîÁ§∫Ê®°Âºè - Êú™Âä†ËΩΩÊ®°Âûã„ÄÇÊ∑ªÂä†ÊÇ®ÁöÑTeachable MachineÊ®°Âûã‰ª•ËøõË°åÁúüÂÆûÊ£ÄÊµã„ÄÇ'
                    };
                    statusEl.textContent = demoMessages[currentLanguage];
                    statusEl.className = 'webcam-status';
                } else {
                    statusEl.textContent = lang['webcam-status-running'];
                    statusEl.className = 'webcam-status success';
                }
                startBtn.style.display = 'none';
                stopBtn.style.display = 'inline-block';
                
                // Start prediction loop
                facialLoop();
                
            } catch (error) {
                console.error('Error initializing facial recognition:', error);
                statusEl.textContent = lang['webcam-status-error'];
                statusEl.className = 'webcam-status error';
                startBtn.disabled = false;
            }
        }

        // Initialize prediction label display
        function initializePredictionLabels() {
            const labelContainer = document.getElementById('label-container');
            labelContainer.innerHTML = '';
            
            // Use the 6 emotions from the game
            const emotionLabels = facialModel ? 
                Array.from({length: facialMaxPredictions}, (_, i) => emotions[i % emotions.length].name) :
                emotions.map(e => e.name);
            
            emotionLabels.forEach((emotionName, i) => {
                const emotion = emotions.find(e => e.name === emotionName) || emotions[i % emotions.length];
                const item = document.createElement('div');
                item.className = 'prediction-item';
                item.id = `prediction-${i}`;
                item.innerHTML = `
                    <div class="prediction-emotion">
                        <span>${emotion.translatedName}</span>
                    </div>
                    <div class="prediction-bar-container">
                        <div class="prediction-bar" id="bar-${i}" style="width: 0%"></div>
                    </div>
                    <div class="prediction-percentage" id="percent-${i}">0%</div>
                `;
                labelContainer.appendChild(item);
            });
        }

        // Initialize demo predictions with balanced starting values
        function initDemoPredictions() {
            demoPredictions = emotions.map((emotion, i) => ({
                className: emotion.name,
                probability: 1 / emotions.length
            }));
            demoTransitionTarget = null;
            demoTransitionProgress = 0;
        }

        // Generate more realistic demo predictions with smooth transitions
        function generateDemoPredictions() {
            // Occasionally change the dominant emotion for demo
            if (!demoTransitionTarget || demoTransitionProgress >= 1) {
                // Pick a new random dominant emotion
                const dominantIndex = Math.floor(Math.random() * emotions.length);
                demoTransitionTarget = emotions.map((emotion, i) => {
                    if (i === dominantIndex) {
                        return 0.5 + Math.random() * 0.3; // 50-80% for dominant
                    } else {
                        return 0.05 + Math.random() * 0.1; // 5-15% for others
                    }
                });
                // Normalize target
                const total = demoTransitionTarget.reduce((sum, p) => sum + p, 0);
                demoTransitionTarget = demoTransitionTarget.map(p => p / total);
                demoTransitionProgress = 0;
            }
            
            // Smoothly interpolate towards target
            demoTransitionProgress += 0.05;
            demoPredictions = emotions.map((emotion, i) => ({
                className: emotion.name,
                probability: demoPredictions[i].probability + 
                    (demoTransitionTarget[i] - demoPredictions[i].probability) * 0.1
            }));
            
            // Add small noise for realism
            demoPredictions.forEach(p => {
                p.probability += (Math.random() - 0.5) * 0.02;
                p.probability = Math.max(0.01, Math.min(0.95, p.probability));
            });
            
            // Normalize
            const total = demoPredictions.reduce((sum, p) => sum + p.probability, 0);
            demoPredictions.forEach(p => p.probability /= total);
            
            return demoPredictions;
        }

        // Prediction loop with frame rate limiting
        async function facialLoop() {
            if (!isFacialRecognitionRunning) return;
            
            facialWebcam.update();
            
            // Throttle predictions to save CPU
            const now = performance.now();
            if (now - lastPredictionTime >= PREDICTION_INTERVAL) {
                lastPredictionTime = now;
                await facialPredict();
            }
            
            facialAnimationId = window.requestAnimationFrame(facialLoop);
        }

        // Run prediction on webcam frame
        async function facialPredict() {
            if (!facialWebcam) return;
            
            let predictions;
            
            if (facialModel) {
                // Use actual model prediction
                predictions = await facialModel.predict(facialWebcam.canvas);
            } else {
                // Demo mode - generate realistic simulated predictions
                predictions = generateDemoPredictions();
            }
            
            // Find the top prediction
            let topPrediction = predictions[0];
            predictions.forEach(p => {
                if (p.probability > topPrediction.probability) {
                    topPrediction = p;
                }
            });
            
            // Update detected emotion display
            const emotion = emotions.find(e => e.name === topPrediction.className) || emotions[0];
            const demoIndicator = isDemoMode ? ' (Demo)' : '';
            document.getElementById('detected-emotion').textContent = 
                `${emotion.translatedName} (${(topPrediction.probability * 100).toFixed(1)}%)${demoIndicator}`;
            
            // Update all prediction bars
            predictions.forEach((prediction, i) => {
                const percentage = (prediction.probability * 100).toFixed(1);
                const bar = document.getElementById(`bar-${i}`);
                const percentEl = document.getElementById(`percent-${i}`);
                const item = document.getElementById(`prediction-${i}`);
                
                if (bar) bar.style.width = `${percentage}%`;
                if (percentEl) percentEl.textContent = `${percentage}%`;
                
                // Highlight top prediction
                if (item) {
                    if (prediction === topPrediction) {
                        item.classList.add('top-prediction');
                        if (bar) bar.classList.add('top-prediction');
                    } else {
                        item.classList.remove('top-prediction');
                        if (bar) bar.classList.remove('top-prediction');
                    }
                }
            });
        }

        // Stop facial recognition
        function stopFacialRecognition() {
            const lang = translations[currentLanguage];
            
            isFacialRecognitionRunning = false;
            isDemoMode = false;
            demoPredictions = null;
            demoTransitionTarget = null;
            
            if (facialAnimationId) {
                window.cancelAnimationFrame(facialAnimationId);
                facialAnimationId = null;
            }
            
            if (facialWebcam) {
                facialWebcam.stop();
                facialWebcam = null;
            }
            
            // Reset UI
            const webcamContainer = document.getElementById('webcam-container');
            if (webcamContainer) webcamContainer.innerHTML = '';
            
            const statusEl = document.getElementById('webcam-status');
            const startBtn = document.getElementById('start-webcam-btn');
            const stopBtn = document.getElementById('stop-webcam-btn');
            const detectedDisplay = document.getElementById('detected-emotion-display');
            const predictionContainer = document.getElementById('prediction-container');
            
            if (statusEl) {
                statusEl.textContent = lang['webcam-status-ready'];
                statusEl.className = 'webcam-status';
            }
            if (startBtn) {
                startBtn.style.display = 'inline-block';
                startBtn.disabled = false;
            }
            if (stopBtn) {
                stopBtn.style.display = 'none';
            }
            if (detectedDisplay) {
                detectedDisplay.style.display = 'none';
            }
            if (predictionContainer) {
                predictionContainer.style.display = 'none';
            }
        }

        // Initialize the game
        updateFlashcard();
        
        // Initialize translations
        updateTranslations();
        
        // Handle audio context for mobile devices
        document.addEventListener('click', () => {
            if (audioContext && audioContext.state === 'suspended') {
                audioContext.resume();
            }
        }, { once: true });
    </script>
 <script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'9a6ac90605f95bd7',t:'MTc2NDUxMDMyNy4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script></body>
</html>
